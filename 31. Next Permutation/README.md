题意：求该排列的下一个排列。

本题也有最省事的写法
  std::next_permutation(num.begin(), num.end());

然鹅，本题就是想让我们实现该函数的功能，还是不能偷懒，好好了解一下~
实现：
在当前序列中，从尾端往前寻找两个相邻元素，前一个记为*i，后一个记为*ii，并且满足*i < *ii。
然后再从尾端寻找另一个元素*j，如果满足*i < *j，即将第i个元素与第j个元素对调，并将第ii个元素之后（包括ii）的所有元素颠倒排序，即求出下一个序列了。

原理：
首先要明确一点，这个排列的下一个排列，应该存在最大的公共前缀。
所以从后往前找到一个字序列有下一个排列。有下一个排列的子序列不应该是倒序的，所以是从后往前找到两个相邻元素，满足 *i < *ii。
接着考虑从i开始的子串的下一个排列，知道i后面的数都是倒序的，所以从后往前，找到第一个比*i小的数，将*i 和 *j 对调，
最后颠倒*ii子串的所有元素。
得到下一个序列
